import { NextRequest } from 'next/server';
import { POST, GET } from '@/app/api/chat/route';
import { getServerSession } from 'next-auth';
import { prisma } from '@/lib/prisma';
// AI Service temporarily removed - tests will be updated with new implementation
import { ValidationUtils } from '@/lib/validation';
import { logger } from '@/lib/logger';
import { monitoring } from '@/lib/monitoring';

// Mock dependencies
jest.mock('next-auth', () => ({
  getServerSession: jest.fn(),
}));

jest.mock('@/lib/prisma', () => ({
  prisma: {
    user: {
      findUnique: jest.fn(),
    },
    chatbotMessage: {
      findMany: jest.fn(),
      create: jest.fn(),
    },
  },
}));

jest.mock('@/lib/ai', () => ({
  __esModule: true,
  default: {
    generateChatbotResponse: jest.fn(),
  },
}));

jest.mock('@/lib/validation', () => ({
  ValidationUtils: {
    validateAndSanitize: jest.fn(),
  },
  chatSchemas: {
    sendMessage: {},
  },
}));

jest.mock('@/lib/logger', () => ({
  logger: {
    logRequest: jest.fn(() => ({ requestId: 'test-id' })),
    logResponse: jest.fn(),
    error: jest.fn(),
  },
}));

jest.mock('@/lib/monitoring', () => ({
  monitoring: {
    recordAPIPerformance: jest.fn(),
  },
}));

jest.mock('@/lib/rate-limit', () => ({
  withRateLimit: (limiter: any, handler: any) => handler,
  chatLimiter: {},
}));

const mockUser = {
  id: 'user-123',
  email: 'test@example.com',
  studyLevel: 'INTERMEDIATE',
  learningStyle: 'visual',
  major: 'Computer Science',
  subjects: [
    {
      subject: { name: 'Mathematics' },
    },
  ],
  goals: [
    {
      title: 'Master Calculus',
      status: 'ACTIVE',
    },
  ],
};

const mockConversationHistory = [
  {
    id: '1',
    message: 'Previous message',
    response: 'Previous response',
    createdAt: new Date(),
  },
];

const mockSession = {
  user: {
    email: 'test@example.com',
  },
};

describe('/api/chat POST', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    (getServerSession as jest.Mock).mockResolvedValue(mockSession);
    (prisma.user.findUnique as jest.Mock).mockResolvedValue(mockUser);
    (prisma.chatbotMessage.findMany as jest.Mock).mockResolvedValue(mockConversationHistory);
    (prisma.chatbotMessage.create as jest.Mock).mockResolvedValue({});
    (ValidationUtils.validateAndSanitize as jest.Mock).mockReturnValue({
      message: 'Test message',
      context: { type: 'general' },
    });
    (AIService.generateChatbotResponse as jest.Mock).mockResolvedValue('AI response');
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  it('handles successful chat message', async () => {
    const request = new NextRequest('http://localhost:3000/api/chat', {
      method: 'POST',
      body: JSON.stringify({
        message: 'Hello AI',
        context: { type: 'general' },
      }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.response).toBe('AI response');
    expect(data.timestamp).toBeDefined();
    expect(data.context).toBe('general');
  });

  it('returns 401 when user is not authenticated', async () => {
    (getServerSession as jest.Mock).mockResolvedValue(null);

    const request = new NextRequest('http://localhost:3000/api/chat', {
      method: 'POST',
      body: JSON.stringify({ message: 'Hello' }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(401);
    expect(data.error).toBe('Unauthorized');
  });

  it('returns 404 when user is not found in database', async () => {
    (prisma.user.findUnique as jest.Mock).mockResolvedValue(null);

    const request = new NextRequest('http://localhost:3000/api/chat', {
      method: 'POST',
      body: JSON.stringify({ message: 'Hello' }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(404);
    expect(data.error).toBe('User not found');
  });

  it('validates and sanitizes request body', async () => {
    const request = new NextRequest('http://localhost:3000/api/chat', {
      method: 'POST',
      body: JSON.stringify({
        message: 'Test message',
        context: { type: 'general' },
      }),
    });

    await POST(request);

    expect(ValidationUtils.validateAndSanitize).toHaveBeenCalledWith(
      {},
      {
        message: 'Test message',
        context: { type: 'general' },
      },
      { sanitize: true }
    );
  });

  it('fetches user with correct includes', async () => {
    const request = new NextRequest('http://localhost:3000/api/chat', {
      method: 'POST',
      body: JSON.stringify({ message: 'Hello' }),
    });

    await POST(request);

    expect(prisma.user.findUnique).toHaveBeenCalledWith({
      where: { email: 'test@example.com' },
      include: {
        subjects: {
          include: { subject: true },
        },
        goals: {
          where: { status: 'ACTIVE' },
        },
      },
    });
  });

  it('fetches conversation history', async () => {
    const request = new NextRequest('http://localhost:3000/api/chat', {
      method: 'POST',
      body: JSON.stringify({ message: 'Hello' }),
    });

    await POST(request);

    expect(prisma.chatbotMessage.findMany).toHaveBeenCalledWith({
      where: { userId: 'user-123' },
      orderBy: { createdAt: 'desc' },
      take: 10,
    });
  });

  it('calls AI service with correct parameters', async () => {
    const request = new NextRequest('http://localhost:3000/api/chat', {
      method: 'POST',
      body: JSON.stringify({ message: 'Test message' }),
    });

    await POST(request);

    expect(AIService.generateChatbotResponse).toHaveBeenCalledWith('Test message', {
      userId: 'user-123',
      conversationHistory: expect.any(Array),
      userProfile: {
        studyLevel: 'INTERMEDIATE',
        learningStyle: 'visual',
        major: 'Computer Science',
        subjects: ['Mathematics'],
        goals: ['Master Calculus'],
      },
    });
  });

  it('saves message to database', async () => {
    const request = new NextRequest('http://localhost:3000/api/chat', {
      method: 'POST',
      body: JSON.stringify({
        message: 'Test message',
        context: { type: 'general', metadata: { test: true } },
      }),
    });

    await POST(request);

    expect(prisma.chatbotMessage.create).toHaveBeenCalledWith({
      data: {
        userId: 'user-123',
        message: 'Test message',
        response: 'AI response',
        messageType: 'general',
        context: '{"test":true}',
      },
    });
  });

  it('records performance metrics', async () => {
    const request = new NextRequest('http://localhost:3000/api/chat', {
      method: 'POST',
      body: JSON.stringify({ message: 'Hello' }),
    });

    await POST(request);

    expect(monitoring.recordAPIPerformance).toHaveBeenCalledWith(
      '/api/chat',
      'POST',
      expect.any(Number),
      200
    );
  });

  it('handles validation errors', async () => {
    const validationError = new Error('Validation failed');
    validationError.name = 'ZodError';
    (ValidationUtils.validateAndSanitize as jest.Mock).mockImplementation(() => {
      throw validationError;
    });

    const request = new NextRequest('http://localhost:3000/api/chat', {
      method: 'POST',
      body: JSON.stringify({ message: 'Invalid' }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.error).toBe('Invalid request format');
  });

  it('handles AI service errors', async () => {
    (AIService.generateChatbotResponse as jest.Mock).mockRejectedValue(
      new Error('AI service failed')
    );

    const request = new NextRequest('http://localhost:3000/api/chat', {
      method: 'POST',
      body: JSON.stringify({ message: 'Hello' }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(500);
    expect(data.error).toBe('Failed to process chat message');
    expect(logger.error).toHaveBeenCalled();
  });

  it('handles database errors', async () => {
    (prisma.chatbotMessage.create as jest.Mock).mockRejectedValue(
      new Error('Database error')
    );

    const request = new NextRequest('http://localhost:3000/api/chat', {
      method: 'POST',
      body: JSON.stringify({ message: 'Hello' }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(500);
    expect(data.error).toBe('Failed to process chat message');
  });

  it('logs request and response', async () => {
    const request = new NextRequest('http://localhost:3000/api/chat', {
      method: 'POST',
      body: JSON.stringify({ message: 'Hello' }),
    });

    await POST(request);

    expect(logger.logRequest).toHaveBeenCalledWith(request);
    expect(logger.logResponse).toHaveBeenCalledWith(
      { requestId: 'test-id' },
      200,
      expect.any(Number)
    );
  });

  it('handles context metadata correctly', async () => {
    const request = new NextRequest('http://localhost:3000/api/chat', {
      method: 'POST',
      body: JSON.stringify({
        message: 'Hello',
        context: {
          type: 'study_plan',
          metadata: { subject: 'Math', difficulty: 'Hard' },
        },
      }),
    });

    (ValidationUtils.validateAndSanitize as jest.Mock).mockReturnValue({
      message: 'Hello',
      context: {
        type: 'study_plan',
        metadata: { subject: 'Math', difficulty: 'Hard' },
      },
    });

    await POST(request);

    expect(prisma.chatbotMessage.create).toHaveBeenCalledWith({
      data: {
        userId: 'user-123',
        message: 'Hello',
        response: 'AI response',
        messageType: 'study_plan',
        context: '{"subject":"Math","difficulty":"Hard"}',
      },
    });
  });
});

describe('/api/chat GET', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    (getServerSession as jest.Mock).mockResolvedValue(mockSession);
    (prisma.user.findUnique as jest.Mock).mockResolvedValue(mockUser);
    (prisma.chatbotMessage.findMany as jest.Mock).mockResolvedValue([
      {
        id: '1',
        message: 'Hello',
        response: 'Hi there!',
        messageType: 'GENERAL',
        helpful: true,
        createdAt: new Date('2024-01-01'),
        context: '{"test": true}',
      },
      {
        id: '2',
        message: 'Help me study',
        response: 'Sure!',
        messageType: 'STUDY',
        helpful: null,
        createdAt: new Date('2024-01-02'),
        context: null,
      },
    ]);
  });

  it('returns chat history successfully', async () => {
    const request = new NextRequest('http://localhost:3000/api/chat');

    const response = await GET(request);
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.conversations).toHaveLength(2);
    expect(data.conversations[0]).toEqual({
      id: '1',
      message: 'Hello',
      response: 'Hi there!',
      type: 'GENERAL',
      helpful: true,
      timestamp: new Date('2024-01-01'),
      context: { test: true },
    });
    expect(data.pagination).toEqual({
      limit: 20,
      offset: 0,
      hasMore: false,
    });
  });

  it('handles pagination parameters', async () => {
    const request = new NextRequest('http://localhost:3000/api/chat?limit=5&offset=10');

    await GET(request);

    expect(prisma.chatbotMessage.findMany).toHaveBeenCalledWith({
      where: { userId: 'user-123' },
      orderBy: { createdAt: 'desc' },
      take: 5,
      skip: 10,
    });
  });

  it('returns 401 when user is not authenticated', async () => {
    (getServerSession as jest.Mock).mockResolvedValue(null);

    const request = new NextRequest('http://localhost:3000/api/chat');

    const response = await GET(request);
    const data = await response.json();

    expect(response.status).toBe(401);
    expect(data.error).toBe('Unauthorized');
  });

  it('returns 404 when user is not found', async () => {
    (prisma.user.findUnique as jest.Mock).mockResolvedValue(null);

    const request = new NextRequest('http://localhost:3000/api/chat');

    const response = await GET(request);
    const data = await response.json();

    expect(response.status).toBe(404);
    expect(data.error).toBe('User not found');
  });

  it('handles database errors in GET', async () => {
    (prisma.chatbotMessage.findMany as jest.Mock).mockRejectedValue(
      new Error('Database error')
    );

    const request = new NextRequest('http://localhost:3000/api/chat');

    const response = await GET(request);
    const data = await response.json();

    expect(response.status).toBe(500);
    expect(data.error).toBe('Failed to fetch chat history');
  });

  it('handles null context correctly', async () => {
    (prisma.chatbotMessage.findMany as jest.Mock).mockResolvedValue([
      {
        id: '1',
        message: 'Test',
        response: 'Response',
        messageType: 'GENERAL',
        helpful: null,
        createdAt: new Date(),
        context: null,
      },
    ]);

    const request = new NextRequest('http://localhost:3000/api/chat');

    const response = await GET(request);
    const data = await response.json();

    expect(data.conversations[0].context).toBeNull();
  });

  it('parses JSON context correctly', async () => {
    (prisma.chatbotMessage.findMany as jest.Mock).mockResolvedValue([
      {
        id: '1',
        message: 'Test',
        response: 'Response',
        messageType: 'GENERAL',
        helpful: null,
        createdAt: new Date(),
        context: '{"key": "value"}',
      },
    ]);

    const request = new NextRequest('http://localhost:3000/api/chat');

    const response = await GET(request);
    const data = await response.json();

    expect(data.conversations[0].context).toEqual({ key: 'value' });
  });

  it('handles malformed JSON context gracefully', async () => {
    (prisma.chatbotMessage.findMany as jest.Mock).mockResolvedValue([
      {
        id: '1',
        message: 'Test',
        response: 'Response',
        messageType: 'GENERAL',
        helpful: null,
        createdAt: new Date(),
        context: 'invalid json',
      },
    ]);

    const request = new NextRequest('http://localhost:3000/api/chat');

    const response = await GET(request);

    // Should not throw error, but handle gracefully
    expect(response.status).toBe(500); // JSON.parse will throw
  });

  it('sets hasMore correctly when there are more results', async () => {
    // Mock 20 results (same as limit) to indicate more might be available
    const mockResults = Array(20).fill(null).map((_, i) => ({
      id: i.toString(),
      message: `Message ${i}`,
      response: `Response ${i}`,
      messageType: 'GENERAL',
      helpful: null,
      createdAt: new Date(),
      context: null,
    }));
    
    (prisma.chatbotMessage.findMany as jest.Mock).mockResolvedValue(mockResults);

    const request = new NextRequest('http://localhost:3000/api/chat?limit=20');

    const response = await GET(request);
    const data = await response.json();

    expect(data.pagination.hasMore).toBe(true);
  });
});